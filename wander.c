//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
  This program will move your robot forward for 2 seconds. At the end of the program, all motors
  will shut down automatically and turn off.
                            ROBOT CONFIGURATION: LEGO EV3 REM Bot
    MOTORS & SENSORS:
    [I/O Port]          [Name]              [Type]                			[Location]
    MotorC        			leftMotor           LEGO EV3 Motor		      Left side motor
    MotorB       				rightMotor          LEGO EV3 Motor		      Right side motor (reversed)
------------------------------------------------------------------------------------------------*/

#define leftMotor 2
#define rightMotor 1
#define leftTouch 0
#define rightTouch 1

#define TURNSPEED 75  //speed of opposite motor to turn
#define LOWSPEED 25   //speed of motor in direction of turn
#define REGSPEED 50   //the normal speed of both motors
#define SHARPSPEED 100  //for turning a sharp corner

#define MINTIME 100  //the minimum time until the next turn
#define MAXTIME 150  //the maximum time until the next turn

#define MINTURN 550  //the minimum time that the robot should be turning
#define MAXTURN 800  //the maximum time that the robot should be turning

#define iLENGTH 3
#define itime 0
#define iturn 1
#define iturntime 2
int irobot[iLENGTH];

/*typedef struct robot_type { //need to change this to an array...
  int time;  //time until turning
  int turn;   //turning right:0 or left:1
  int turntime; //time of the turn; determines degree
} robot;
typedef robot* robot_ptr;*/

/*(int setMotorSpeed(int mnum, int speed) {
	motor[mnum] = speed;
	return 0;
}*/

int my_rand(int min, int max) {
  int num = (rand()%(max-min))+min;
  return abs(num);
}

int reset_motor() {
  setMotorSpeed(leftMotor, REGSPEED);
  setMotorSpeed(rightMotor, REGSPEED);
  irobot[itime] = my_rand(MINTIME, MAXTIME);
  //irobot[itime] = 2;
  irobot[iturntime] = my_rand(MINTURN, MAXTURN);
  return 0;
}

int turn_right() {
  //if (irobot[itime] == 0) {
    setMotorSpeed(leftMotor, TURNSPEED);
    setMotorSpeed(rightMotor, LOWSPEED);
    irobot[iturn] = 1;
    sleep(irobot[iturntime]);
    return 1;
  //}
  //irobot[itime] = irobot[itime]-1;
  return 0;
}

int turn_left() {
  //if (irobot[itime] == 0) {
    setMotorSpeed(rightMotor, TURNSPEED);
    setMotorSpeed(leftMotor, LOWSPEED);
    irobot[iturn] = 0;
    sleep(irobot[iturntime]);
    return 1;
  //}
  //irobot[itime] = irobot[itime]-1;
  return 0;
}

int backup(int duration) {
  setMotorSpeed(leftMotor, -REGSPEED);	//Set the leftMotor (motor1) to half power (50)
  setMotorSpeed(rightMotor, -REGSPEED);  //Set the rightMotor (motor6) to half power (50)
  sleep(duration);
  return 0;
}

int reverse() {
  setMotorSpeed(leftMotor, -SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(rightMotor, SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  sleep(500);
  return 0;
}

int turn_right_sharp() {
  setMotorSpeed(leftMotor, -SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(rightMotor, SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  irobot[iturn] = 1; //keep going right
  sleep(250);
  return 0;
}

int turn_left_sharp() {
  setMotorSpeed(leftMotor, SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(rightMotor, -SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  irobot[iturn] = 0; //keep going left
  sleep(250);
  return 0;
}

int check_touch() {
	//Loop to monitor value in Sensor debugger window
  if (SensorValue[leftTouch] && SensorValue[rightTouch]) { //backup
    setLEDColor(ledOff);
    backup(1000);
    reverse();
    reset_motor();
  } else if (SensorValue[leftTouch]) { // When left sensor is touch
    displayCenteredBigTextLine(4, "Pressed!");
    setLEDColor(ledRed);
    backup(250);
    turn_left_sharp();
    reset_motor();
  } else if (SensorValue[rightTouch]) { // When right sensor is touch
    setLEDColor(ledOrange);
    backup(250);
    turn_right_sharp();
    reset_motor();
  } else {
    displayCenteredBigTextLine(4, "Not Pressed!");
    setLEDColor(ledGreen);
  }
  return 0;
}
int run = 0;
task main() {
  run = 1;
  srand(500);
  reset_motor();
  //do a turn every 100 runs or so
  while (run) {
    //we may be changing directions
  	check_touch();
  	if (run % irobot[itime] == 0) {
    	if (irobot[iturn]) {
      	turn_left();
      	reset_motor();
    	} else {
      	turn_right();
      	reset_motor();
    	}
  	}
    sleep(50);
    run = run + 1;
  }
}
