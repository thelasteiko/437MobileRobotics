#pragma config(StandardModel, "EV3_REMBOT")
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
  This program will move your robot forward for 2 seconds. At the end of the program, all motors
  will shut down automatically and turn off.

                            ROBOT CONFIGURATION: LEGO EV3 REM Bot
    MOTORS & SENSORS:
    [I/O Port]          [Name]              [Type]                			[Location]
    MotorC        			leftMotor           LEGO EV3 Motor		      Left side motor
    MotorB       				rightMotor          LEGO EV3 Motor		      Right side motor (reversed)
------------------------------------------------------------------------------------------------*/

#define TURNSPEED 75  //speed of opposite motor to turn
#define LOWSPEED 25   //speed of motor in direction of turn
#define REGSPEED 50   //the normal speed of both motors
#define SHARPSPEED 100  //for turning a sharp corner

#define MINTIME 5000  //the minimum time until the next turn
#define MAXTIME 8000  //the maximum time until the next turn

#define MINTURN 100  //the minimum time that the robot should be turning
#define MAXTURN 250  //the maximum time that the robot should be turning

#define iLENGTH
#define itime 0
#define iturn 1
#define iturntime 2
int irobot[iLENGTH];

/*typedef struct robot_type { //need to change this to an array...
  int time;  //time until turning
  int turn;   //turning right:0 or left:1
  int turntime; //time of the turn; determines degree
} robot;
typedef robot* robot_ptr;*/

int my_random(int min, int max) {
  return (rand()%(max-min))+min;
}

int reset_motor() {
  setMotorSpeed(leftMotor, REGSPEED);
  setMotorSpeed(rightMotor, REGSPEED);
  irobot[itime] = my_rand(MINTIME, MAXTIME);
  irobot[iturntime] = my_rand(MINTURN, MAXTURN);
}

int turn_right() {
  if (irobot[itime] == 0) {
    setMotorSpeed(leftMotor, TURNSPEED);
    setMotorSpeed(rightMotor, LOWSPEED);
    irobot[iturn] = 1;
    sleep(irobot[iturntime]);
    return 1;
  }
  irobot[itime] = irobot[itime]-1;
  return 0;
}

int turn_left() {
  if (irobot[itime] == 0) {
    setMotorSpeed(rightMotor, TURNSPEED);
    setMotorSpeed(leftMotor, LOWSPEED);
    irobot[iturn] = 0;
    sleep(irobot[iturntime]);
    return 1;
  }
  irobot[itime] = irobot[itime]-1;
  return 0;
}

int backup(int duration) {
  setMotorSpeed(motorLeft, -REGSPEED);	//Set the leftMotor (motor1) to half power (50)
  setMotorSpeed(motorRight, -REGSPEED);  //Set the rightMotor (motor6) to half power (50)
  sleep(duration);
  return 0;
}

int reverse() {
  setMotorSpeed(motorLeft, -SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(motorRight, SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  sleep(500);
  return 0;
}

int turn_right_sharp() {
  setMotorSpeed(motorLeft, -SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(motorRight, SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  irobot[iturn] = 0; //keep going right
  sleep(250);
  return 0;
}

int turn_left_sharp() {
  setMotorSpeed(motorLeft, SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(motorRight, -SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  irobot[iturn] = 1; //keep going left
  sleep(250);
  return 0;
}

task main() {
  int run = 1000;
  srand(nSeedValue);
  reset_motor();
  
  while (run) {    
    //Loop to monitor value in Sensor debugger window
    if (SensorValue[Touch2] && SensorValue[Touch]) { //backup
      setLEDColor(ledOff);
      backup(1000);
      reverse();
      reset_motor();
    } else if (SensorValue[Touch]) { // When left sensor is touch
      displayCenteredBigTextLine(4, "Pressed!");
      setLEDColor(ledRed);
      backup(250);
      turn_right_sharp();
      reset_motor();
    } else if (SensorValue[Touch2]) { // When right sensor is touch
      setLEDColor(ledOrange);
      backup(250);
      turn_left_sharp();
      reset_motor();
    } else {
      displayCenteredBigTextLine(4, "Not Pressed!");
      setLEDColor(ledGreen);
    }
    //we may be changing directions
    if (irobot[iturn]) {
      turn_left();
      reset_motor();
    } else {
      turn_right();
      reset_motor();
    }
    sleep(irobot[iturntime]);
  }
}
