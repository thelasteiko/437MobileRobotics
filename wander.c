//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*------------------------------------------------------------------------------------------------
  This program will move your robot forward for 2 seconds. At the end of the program, all motors
  will shut down automatically and turn off.
                            ROBOT CONFIGURATION: LEGO EV3 REM Bot
    MOTORS & SENSORS:
    [I/O Port]          [Name]              [Type]                			[Location]
    MotorC        			leftMotor           LEGO EV3 Motor		      Left side motor
    MotorB       				rightMotor          LEGO EV3 Motor		      Right side motor (reversed)
------------------------------------------------------------------------------------------------*/

#define leftMotor 2
#define rightMotor 1
#define leftTouch 0
#define rightTouch 1

#define TURNSPEED 75  //speed of opposite motor to turn
#define LOWSPEED 25   //speed of motor in direction of turn
#define REGSPEED 50   //the normal speed of both motors
#define SHARPSPEED 100  //for turning a sharp corner

#define MINTIME 3  //the minimum numbeer of cycles until the next turn
#define MAXTIME 4  //the maximum number of cycles until the next turn

#define MINTURN 11 //550  //the minimum number of cycles that the robot should be turning
#define MAXTURN 16 //800  //the maximum number of cycles that the robot should be turning

#define iLENGTH 3   //the length of the array
#define itime 0     //the number of cycles until the next turn
#define iturn 1     //the next turn to take; right:0, left:1
#define iturntime 2 //the number of cycles to be turning
int irobot[iLENGTH];

int my_rand(int min, int max) {
  /*Returns a random number between the min and max.*/
  int num = (rand()%(max-min))+min;
  return abs(num);
}

int reset_motor() {
  /*Resets the speed of the motors to go forward
    and the values for determining when to turn.*/
  setMotorSpeed(leftMotor, REGSPEED);
  setMotorSpeed(rightMotor, REGSPEED);
  //reset time until turn
  irobot[itime] = my_rand(MINTIME, MAXTIME);
  irobot[iturntime] = -1;
  return 0;
}

int turn_right() {
  /*Sets the motors to turn right.*/
    setMotorSpeed(leftMotor, TURNSPEED);
    setMotorSpeed(rightMotor, LOWSPEED);
    //reset time until stop turning
    irobot[iturntime] = my_rand(MINTURN, MAXTURN);
    irobot[iturn] = 1;
  return 0;
}

int turn_left() {
  /*Sets the motors to turn left.*/
    setMotorSpeed(rightMotor, TURNSPEED);
    setMotorSpeed(leftMotor, LOWSPEED);
    //reset time until stop turning
    irobot[iturntime] = my_rand(MINTURN, MAXTURN);
    irobot[iturn] = 0;
  return 0;
}

int backup(int duration) {
  /*Sets the motors to reverse direction.*/
  setMotorSpeed(leftMotor, -REGSPEED);	//Set the leftMotor (motor1) to half power (50)
  setMotorSpeed(rightMotor, -REGSPEED);  //Set the rightMotor (motor6) to half power (50)
  sleep(duration);
  return 0;
}

int reverse() {
  /*Turns the unit all the way around.*/
  setMotorSpeed(leftMotor, -SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(rightMotor, SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  sleep(500);
  return 0;
}

int turn_right_sharp() {
  /*Turns a sharp right.*/
  setMotorSpeed(leftMotor, -SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(rightMotor, SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  irobot[iturn] = 1; //keep going right
  sleep(250);
  return 0;
}

int turn_left_sharp() {
  /*Turns a sharp left.*/
  setMotorSpeed(leftMotor, SHARPSPEED);		//Set the leftMotor (motor1) to full power reverse (-100)
  setMotorSpeed(rightMotor, -SHARPSPEED);  	//Set the rightMotor (motor6) to full power forward (100)
  irobot[iturn] = 0; //keep going left
  sleep(250);
  return 0;
}

int check_touch(int run, int prev_turn, int count, int check) {
  /*Checks if one of the bumpers was touched
    and responds appropriately.*/
  if (SensorValue[leftTouch] && SensorValue[rightTouch]) { //backup
    setLEDColor(ledOff);
    backup(1000);
    reverse();
    reset_motor();
  } else if (count >= 3) {
  	count = 0;
  	setLEDColor(ledOff);
    backup(1000);
    reverse();
    reset_motor();
	} else if (SensorValue[leftTouch]) { // When left sensor is touch
    displayCenteredBigTextLine(4, "Pressed!");
    setLEDColor(ledRed);
    backup(250);
    turn_left_sharp();
    reset_motor();
    if(run - prev_turn < 5 && check != 0) {    	
    	count++;
  	} else {
  		count = 0;
  	}
  	prev_turn = run;
  	check = 0;
  } else if (SensorValue[rightTouch]) { // When right sensor is touch
    setLEDColor(ledOrange);
    backup(250);
    turn_right_sharp();
    reset_motor();
    if(run - prev_turn < 5 && check != 1) {    	
    	count++;
  	} else {
  		count = 0;
  	}
    prev_turn = run;
    check = 1;
  } else {
    displayCenteredBigTextLine(4, "Not Pressed!");
    setLEDColor(ledGreen);
  }
  return prev_turn;
}
task main() {
  /*The main task containing a loop that checks
    for sensor input and determines whether to turn.*/
  int run = 1;
  srand(500);
  reset_motor();
  int prev_turn, count = 0;
  int check = 2; //left = 1, right = 0
  //do a turn every 100 runs or so
  while (run) {
  	
  	prev_turn = check_touch(run, prev_turn, count, check);
    if (irobot[iturntime] > 0) { //currently turning
      irobot[iturntime] = irobot[iturntime]-1;
    } else if (irobot[iturntime] == 0){ //stop turning
      irobot[iturntime] = -1;
      //end turning and reset motor
      reset_motor();
    }
  	if (irobot[iturntime] < 0) { //should not be turning
      if (irobot[itime]) { //wait until zero to turn
        irobot[itime] = irobot[itime]-1;
      } else { //time to turn
        if (irobot[iturn]) {
          turn_left();
        } else {
          turn_right();
        }
      }
    }
    sleep(50);
    run = run + 1;
  }
}
